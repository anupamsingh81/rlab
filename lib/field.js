// module : Field & Group Theory
var F = {}
F.Integer=require("./integer");
S = F.Set=require("./set");
var eq = F.Set.eq;
// ========== Group =================
// 注意： 箭頭函數會自動將 this 變數綁定到其定義時所在的物件，因此以下很多地方不能用箭頭函數。
// 參考： https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/Arrow_functions
F.Group={ 
  invOp:function(x,y) { 
    return this.op(x,this.inv(y)); 
  },
  power:function(x,n) {
    var p=this.e;
    for (var i=0;i<n;i++) {
      p=this.op(p,x);
    }
    return p;
  },
	leftCoset:function(g, H) {
		var set = new S.Set();
		for (var i in H)
		  set.add(this.op(g,H[i]));
		return set;
	},
	rightCoset:function(H, g) {
		var set = new S.Set();
		for (var i in H)
		  set.add(this.op(g,H[i]));
		return set;
	},
  // ref:https://en.wikipedia.org/wiki/Group_(mathematics)
  // 封閉性：For all a, b in G, a • b, is also in G
  closability:function(a,b) {
		var ab = this.op(a,b);
    var close=this.has(ab);
    return this.has(this.op(a,b));
  },
  // 結合性：For all a, b and c in G, (a • b) • c = a • (b • c).
  associativity:function(a,b,c) {
    var op = this.op.bind(this);
    return eq(op(op(a,b),c), op(a,op(b,c)))
  },
  // 單位元素：Identity element
  identity:function(a) {
    return eq(this.op(this.e,a),a)
  },
  // 反元素：Inverse element
  inversability:function(a) {
    return eq(this.op(a,this.inv(a)),this.e);
  },
}

// PermutationGroup
F.PermutationGroup={
  op:function(x,y) {
	  var z = [];
		for (var i in x)
			z[i] = y[x[i]];
		return z;
  },
  inv:function(x) { 
	  var nx = [];
		for (var i in x) {
			nx[x[i]] = i;
		}
	  return nx;
	},
}

extend(F.PermutationGroup, F.Group);

// Cyclic Group :  a group that is generated by a single element (g)
F.CyclicGroup={
	G:[],
//	g:g,
  op:function(x,y) {
  },
  inv:function(x) {
	},
	create(g) {
		var t = e;
		for (var i=0; !t.eq(e); i++) {
			G[i]=t;
			t=op(g,G[i]);
		}
	}
}

extend(F.CyclicGroup, F.Group);

// NormalSubGroup : 正規子群
F.NormalSubGroup={
  op:function(x,y) {
  },
  inv:function(x) {
	},
	normality(g,n) {
		return this.has(g.op(n).op(g.inv()));
	},
}

extend(F.NormalSubGroup, F.Group);

// Quotent Group : aggregating similar elements of a larger group using an equivalence relation that preserves the group structure

F.QuotentGroup={
	eq:function(x,y) {
		
	},
  op:function(x,y) {
  },
  inv:function(x) {
	},
}

extend(F.QuotentGroup, F.Group);

// Normal SubGroup : gH = Hg
// https://en.wikipedia.org/wiki/Normal_subgroup
F.NormalSubGroup={
  op:function(x,y) {
  },
  inv:function(x) {
	},
}

extend(F.NormalSubGroup, F.Group);

// 群同構第一定理： 給定 GG和 G ′ 兩個群，和 f : G → G ′ 群同態。則 Ker ⁡ f 是一個 G 的正規子群。
// 群同構第二定理：給定群 G 、其正規子群 N、其子群 H，則 N ∩ H 是 H 的正規子群，且我們有群同構如下： H / ( H ∩ N ) ≃ H N / N
// 群同構第三定理： 給定群 G， N 和 M，M 為 G 的正規子群，滿足 M 包含於 N ，則 N / M 是 G / M 的正規子群，且有如下的群同構： ( G / M ) / ( N / M ) ≃ G / N .

// ========== Field =================
F.Field={
  sub:function(x,y) { return this.addGroup.invOp(x,y) },
  div:function(x,y) { return this.mulGroup.invOp(x,y) },
//  mod:function(x,y) { return x.sub(x.div(y).mul(y)) },
  power:function(x,n) { return this.mulGroup.power(x,n) },
  init:function(addGroup, mulGroup) {
    this.addGroup = addGroup;
    this.mulGroup = mulGroup;
    this.zero = addGroup.e;
    this.add  = function(x,y) { return this.addGroup.op(x,y) }
    this.neg  = function(x) { return this.addGroup.inv(x) }
    this.one  = mulGroup.e;
    this.mul  = function(x,y) { return this.mulGroup.op(x,y) }
    this.inv  = function(x) { return this.mulGroup.inv(x) }
    this.power= function(x,n) { return this.mulGroup.power(x,n) }
		this.eq   = function(x,y) { return S.eq(x,y); }
		this.neq  = function(x,y) { return !this.eq(x,y); }
		this.isZero = function(x) { 
		  return this.field.eq(this, S.proto(this).zero) 
		}
		this.isOne = function(x) { 
		  return this.field.eq(this, S.proto(this).one)
		}
		this.gcd  = function(x,y) {
			if (y.isZero()) return x;
			return gcd(y, mod(x,y));
		}
  },
	ldistribute:function(a,b,c) {
		return this.mul(a, this.add(b,c)).eq(this.add(this.mul(a,b), this.mul(a,c)));
	},
	rdistribute:function(a,b,c) {
		return this.ldistribute(b,c,a);
	},
	associativity:function(a,b,c) {
		return this.mul(a,this.mul(b,c)).eq(this.mul(this.mul(a,b),c));
	},
}

F.Ring = F.Field;  // Ring  (環)  : 可能沒有乘法單位元素和反元素的 Field
F.Module = F.Field;// Module(模)  : (R +) is Ring, (R × M → M)
F.Ideal = F.Field; // Ideal (理想): 子環，且 i·r ∈ I (左理想), r·i ∈ I (右理想)

// ref : https://en.wikipedia.org/wiki/Group_homomorphism
//  https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms
// 同態：h(a • b) = h(a) x h(b) 
F.homomorphism=function(h, g1, g2) {
  var a=g1.random(), b=g2.random();
  return eq(h(group1.op(a,b)), group2.op(h(a), h(b)))
}

// ref : https://en.wikipedia.org/wiki/Isomorphism
//  https://en.wikipedia.org/wiki/Isomorphism_theorem
// 同構：h(a • b) = h(a) • h(b)
F.isomorphism=function(h1, h2, g1, g2) {
  var a1=g1.random(), b1=g2.random();
  var a2=g1.random(), b2=g2.random();
  return homorphism(h1,g1,g2)&&homorphism(h2,g2,g1);
}

// ========== Float Field =================
F.FloatAddGroup={
  e:0,
  op:function(x,y) { return x+y },
  inv:function(x) { return -x},
}

extend(F.FloatAddGroup, F.Group, F.Set.Float);

F.FloatMulGroup={
  e:1,
  op:function(x,y) { return x*y },
  inv:function(x) { return 1/x},
}

extend(F.FloatMulGroup, F.Group, F.Set.Float);

F.FloatField=extend({}, F.Field, F.Set.Float);

F.FloatField.init(F.FloatAddGroup, F.FloatMulGroup);

// ========== Finite Field =================
F.FiniteAddGroup={
  e:0,
  op:function(x,y) { return (x+y)%this.n },
  inv:function(x) { return (this.n-x) }
}

extend(F.FiniteAddGroup, F.Group);

F.FiniteMulGroup={
  e:1,
  op:function(x,y) { return (x*y)%this.n }, 
  inv:function(x) { return this.invMap[x] },
  setOrder:function(n) {
    this.n = n;
    let invMap = new Map();
    for (var x=1; x<n; x++) {
      var y = this.op(x,x);
      invMap.set(x,y);
    }
    this.invMap = invMap;
  }
}

extend(F.FiniteMulGroup, F.Group);

F.FiniteField=extend({}, F.Field);

F.FiniteField.create=function(n) {
  var finiteField = extend(F.Set.Finite(n), F.FiniteField);
  var addGroup = extend(F.Set.Finite(n), {n:n}, F.FiniteAddGroup);
  var mulGroup = extend(F.Set.Finite(n), {n:n}, F.FiniteMulGroup);
  finiteField.init(addGroup, mulGroup);
  mulGroup.setOrder(n);
  return finiteField;
}

class MathObj {
  constructor() {}
  str() { return this.toString() }
}

F.MathObj = MathObj;

// =========== Field Object ==============
class FieldObj extends MathObj {
  constructor(field) { 
    super();
    this.field = field;
		var p = Object.getPrototypeOf(this);
		p.zero = field.zero;
		p.one = field.one;
  }
  
  add(y) { return this.field.add(this,y) }
  mul(y) { return this.field.mul(this,y) }
  neg() { return this.field.neg(this) }
  inv() { return this.field.inv(this) }
  div(y) { return this.field.div(this,y) }
  sub(y) { return this.field.sub(this,y) }
  power(n) { return this.field.power(this,n) }
	isZero(x) { return this.field.isZero(this) }
	isOne(x) { return this.field.isOne(this) }
  eq(y) { return this.field.eq(this, y) }
	neq(y) { return this.field.neq(this, y) }
	mod(y) { return this.field.mod(this, y) }
	gcd(y) { return this.field.gcd(this, y) }
}

F.FieldObj = FieldObj;

// =========== Complex Field ==============
F.ComplexField=extend({}, F.Field);

class Complex extends FieldObj {
  constructor(a,b) {
    super(F.ComplexField);
    this.a = a; this.b = b; 
  }
  conj() { return new Complex(this.a, -1*this.b); }
  
	str() { 
    var op = (this.b<0)?'':'+';
	  return this.a.str()+op+this.b.str()+'i';
	}
  toString() { return this.str() }
  
	toPolar() {
    var a=this.a, b=this.b, r=Math.sqrt(a*a+b*b);
    var theta = Math.acos(a/r);
		return {r:r, theta:theta}
	}
	
	power(k) {
		var p = this.toPolar();
		return Complex.polarToComplex(Math.pow(p.r,k), k*p.theta);
	}
	
	sqrt() {
		return this.power(1/2);
	}
	
	static toComplex(o) {
		if (S.isFloat(o))
			return new Complex(o, 0);
		else if (o instanceof Complex)
			return o;
		console.log('o=', o);
		throw Error('toComplex fail');
	}
	
	static polarToComplex(r,theta) {
    var a=r*Math.cos(theta), b=r*Math.sin(theta);
		return new Complex(a, b);
	}
	
  static parse(s) {
    var m = s.match(/^([^\+]*)(\+(.*))?$/);
    var a = parseFloat(m[1]);
    var b = typeof m[3]==='undefined'?1:parseFloat(m[3]);
    return new Complex(a, b)
  }
}

F.Complex = Complex;
var C = (a,b)=>new Complex(a,b);
var enumComplex=[C(1,0),C(0,1),C(0,0),C(2,3),C(-5,4),C(-10,-7)];
F.ComplexSet=new S.Set(enumComplex);
F.ComplexSet.has = (a)=>a instanceof Complex;

F.ComplexAddGroup={
  e:new Complex(0,0),
  op:function(x,y) { 
	  x = Complex.toComplex(x), y=Complex.toComplex(y);
	  return new Complex(x.a+y.a, x.b+y.b) 
	},
  inv:function(x) { 
	  x = Complex.toComplex(x);
	  return new Complex(-x.a, -x.b) 
	}
}

extend(F.ComplexAddGroup, F.Group, F.ComplexSet);

F.ComplexMulGroup={
  e:new Complex(1,0),
  op:function(x,y) {
	  x = Complex.toComplex(x), y=Complex.toComplex(y);
    return new Complex(x.a*y.a-x.b*y.b, x.a*y.b+x.b*y.a);
  },
  inv:function(x) {
	  x = Complex.toComplex(x);
    var a=x.a,b=x.b, r=(a*a+b*b);
    return new Complex(a/r, -b/r);
  } 
}

extend(F.ComplexMulGroup, F.Group, F.ComplexSet);

extend(F.ComplexField, F.ComplexSet);

F.ComplexField.init(F.ComplexAddGroup, F.ComplexMulGroup);

// =========== Ratio Field ==============
F.RatioField=extend({}, F.Field);

class Ratio extends FieldObj {
  constructor(a,b) {
    super(F.RatioField);
    this.a = a; this.b = b; 
  }

  reduce() {
    var a = this.a, b=this.b;
    var c = F.Integer.gcd(a, b);
    return new Ratio(a/c, b/c);
  }
  
  toString() { return this.a+'/'+this.b; }

  static parse(s) {
    var m = s.match(/^(\d+)(\/(\d+))?$/);
    var a = parseInt(m[1]);
    var b = typeof m[3]==='undefined'?1:parseInt(m[3]);
    return new Ratio(a, b)
  } 
}

F.Ratio = Ratio;

F.RatioAddGroup={
  e:new Ratio(0,1),
  op:function(x,y) { return new Ratio(x.a*y.b+x.b*y.a, x.b*y.b) },
  inv:function(x) { return new Ratio(-x.a, x.b); },
}
  
extend(F.RatioAddGroup, F.Group);

F.RatioMulGroup={
  e:new Ratio(1,1),
  op:function(x,y) { return new Ratio(x.a*y.a, x.b*y.b) },
  inv:function(x) { return new Ratio(x.b, x.a) },
}

extend(F.RatioMulGroup, F.Group);

F.RatioField.init(F.RatioAddGroup, F.RatioMulGroup);

module.exports = F;

